%
% DO NOT CHANGE THIS TEMPLATE!
%
% To allow combining the lecture notes from different scribes in a
% simple way all scribes must use the same header.
%
% If you think the template lack a package, then contact the lecturer,
% and we will probably extend the template with your favorite package.
%

\documentclass[11pt,a4paper,twoside]{article}
\usepackage{alg}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{subfigure}
\usepackage{amssymb}
\usepackage{amsmath}

\begin{document}
\pagestyle{myheadings}
\thispagestyle{plain}

\newcommand{\lecture}[5] { %
\newcommand{\fdatum}{#1}%
\newcommand{\fnummer}{#2}%
\newcommand{\frubrik}{#3}%
\newcommand{\fforelasare}{#4}%
\newcommand{\fskribent}{#5}%
\markboth{DD2458 -- Popup VT 2011}{\frubrik}%
\hrule
\begin{center}
\large \bf 
DD2458, Problem Solving and Programming Under Pressure

\vspace*{2mm}
\Large \bf 
Lecture \fnummer: \frubrik
\end{center}
\small
\noindent Date: \fdatum
\\
Scribe(s): \fskribent
\\
Lecturer: \fforelasare
\\
\hrule
\vspace{5mm}
}


\newtheorem{theorem}{Theorem}[section]
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{claim}[theorem]{Claim}
\newtheorem{definition}[theorem]{Definition}

% \lecture{date}{lecture number}{lecture headline}{lecturer}{scribe}
%
%
%

%%%%% Edit after this row. The above should not need editing. %%%%%

%%%%% Define your own stuff here. %%%%%

\newcommand{\zed}{\mathbb{Z}}
\newcommand{\nat}{\mathbb{N}}
\newcommand{\GF}[1]{\mathrm{GF}_{#1}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\lecture{2011-02-01}{3}{The Hitchhiker's Guide to Debugging and Testing}{Alexander Baltatzis}{Joel Bohman, Linus Wallgren, Oskar Werkelin Ahlin}

\noindent
Debugging is the art of finding bugs in code and to be able to get rid of them.
Nowadays, this art has become a serious profession for many programmers, who
spend their working days hunting bugs. The first step in learning about
debugging is to know about one of the most well-know bugs in history. In 1946,
at Harvard University, a moth caused a system failure by being trapped inside a
relay in one of the electromechanical computers used at the time. Even though
it is not common nowadays that program bugs are caused by actual insects, their
source is still often evasive and hard to detect. This is a short guide for
anyone interested in learning more about debugging and testing.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Testing}

Testing the code you have written is of great importance. It is the way you
confirm that your program runs the way you expect it to. Having a well tested
program means that you can be sure the program will not behave unexpectedly.
There are a number of testing techniques available and the most important ones
are listed below.


\subsection{Documenting tests using a test matrix}

You should always document your tests, in order to be able to look back and see
what you tested and did not test before, and what happened if you ran the
program in that specific way. A test matrix is a good way to implement the
fundamental ideas of documented testing. It contains a collection of tests, and
for each test we list four points:

\begin{itemize}
    \item Prerequisites - what are the conditions for running this test?
    \item The test itself - what part of the program does it execute?
    \item The expected result - what do we expect to achieve?
    \item The results from the program - what result did we get?
\end{itemize}

Following this principle, a matrix is formed as we fill it up with rows, for example:

\begin{center}
\begin{tabular}{|l|p{2.5cm}|p{2cm}|p{2.5cm}|p{2.5cm}|}
\hline
Test \# & Prerequisites & The test & Expected result & Test results \\ \hline 1
& Compiled with g++ -O2 -g on an Intel x86-64 architecture, debian stable. &
Provoke the program to divide by zero. & An error mentioning divide by zero. &
The system crashed and burned. \\
\hline
\end{tabular}
\end{center}

This is a comprehensive way to document your testing. As the matrix fills up,
more knowledge is gained about the programâ€™s functionality, and actions can be
taken thereafter. Documenting your tests in a similar manner is strongly
advisable.
 

\subsection{State-based testing}

This is a way of testing the program using abstract states and state
transitions. First, define different states in the program. Then define
transitions between these states. Transitions are caused by program events. The
goal is to confirm that the program changes state properly. Given a starting
state (e.g. specific program input), we want to make sure that the transition
(e.g. a calculation) takes us to the correct final state (e.g. outputting the
correct result). A state is often closely related to the current values of the
different program variables.
 

\subsubsection{Boundary values}

\subsubsection{Well defined behaviour}

\subsection{Behavioural testing}

\subsection{Testing manually}

\subsection{Automated testing}

\subsubsection{Unit testing}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{When an error occurs}

\subsection{Errors}

\subsubsection{Compile errors}

This is an error that you receive when you compile your code. The compiler
stops and tells you there is an error that must be fixed before it can be
compiled. Compile time errors are the most preferable errors, as you notice
them right away and can correct them fast. In some programming languages, some
logical errors will transform into compile errors, due to strong typing in that
particular language. 

\subsubsection{Warnings}

Compile time warnings generally do not stop the compiling process, but they are
usually good to take care of. It might be that you get warnings which are
unavoidable, for example warnings about deprecated methods. If a large amount
of these are generated at compile time, more serious warnings might be
overlooked, because of the sheer amount of warnings. If you get warnings that
you know will nott do any harm, it is advisable to use compiler flags to hide
these. In gcc, this can be done using the -W flag.

\subsubsection{Run time errors}

A run time error occurs after compilation and during the execution of the
program. Run time errors are programming errors not detectable by the compiler,
making them hard to detect and remove. An example of a typical run time error
is when you try to access an array element outside of the array boundaries or
when you try to follow a null pointer.

\subsubsection{Logical errors}

Logical errors are the most difficult kinds of errors. They are especially
difficult to detect as there is nothing technically wrong. The error is only in
the behaviour of the program. As these are the most difficult errors to handle
we need to employ a couple of debugging techniques.


\subsection{Debugging}

\subsubsection{Trace output}

\subsubsection{Logging}

\subsection{Tools}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Models}

\subsection{Test-driven}

\subsection{Contract programming}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{If you get stuck}

If you managed to read this far you are now most certainly ready start your
quest to perfect the art of debugging. Because hunting bugs can be a tiresome
activity that can make the most sane person insane, you need a couple of tips
to carry with you. If you find yourself in the situation where you are stuck
and all hope seems gone, try one of the following: 

\begin{itemize} 
    \item Do something else! A fresh mind and body can do miracles. Take a walk.
          Have something to eat. Sleep on it. 
    \item Try to explain the problem to another person. By explaining your 
          problem in words it will get you to think about the problem and you 
          might see it from a new perspective.  
    \begin{itemize}
        \item If this does not help, show that person or any other person
              your code. Another pair of eyes can see something you might have 
              missed. This is called peer-reviewing.
    \end{itemize}
    
    \item Start from the beginning. Understanding the logic to solve an 
          assignment is what a programmer spend most time doing. When you have
          the logic down you can write code in a higher pace. Chances are you
          will not hit the same problem the second time around. Refactoring your
          code is often faster than trying to figure out what was wrong with 
          your first version.
\end{itemize}

\end{document}
